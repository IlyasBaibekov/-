# Реализация на языке си (c) Есть операции умножения, сложения, вычитания, деления, редукции и еще несколько полезных функций

В программе вы, как в райском саду, имеете право делать все что захотите. Запрещается только есть яблок... Запрещается только использовать функции, меняющие многочлены, предварительно их не отредуцировав.
Поэтому перед выполнением каких-либо операций с многочленами отредуцируйте их, иначе арифметика не будет работать корректно всегда


Опишем, что делают функции:

sum, sub, mul, divv - арифметические операции в конечном поле
Принимают функции два числа, с которыми нужно произвести действие, а также n - основание поля
В дальнейшем -> будем обозначать возврат функции

reducing(число, основание поля):  -> отредуцированное по основанию поля число

В остальных функциях, для удобства, N задается в начале программы через define. 

createNode(степень одночлена, коэффициент) -> struct Node* - указатель на одночлен

createpoly() -> struct Node* - создает многочлен с консоли

addNode(указатель на struct Node*, степень, коэффициент) -> ничего не возвращает, но изменяет struct Node*, который передали

printpoly(struct Node*) -> ничего не возвращает, печатает многочлен на экран

copyPoly(struct Node*) -> struct Node* - копирует многочлен 

createEmptyPoly(степень многочлена) -> struct Node* - создает многочлен с нулевыми коэффициентами

isZeroPoly(struct Node*) -> -1, если нашелся ненулевой коэффициент, 1 иначе 

freePoly(struct Node*) -> ничего  не возвращает - очищает память 

Addpoly(struct Node*, struct Node*) -> struct Node* - результат сложения первого многочлена с вторым в поле

Subpoly(struct Node*, struct Node*) -> struct Node* - результат вычитания второго многочлена из первого в поле

Multipoly(struct Node*, struct Node*) -> struct Node* - результат умножения первого многочлена на второй в поле

Delenie(struct Node*, struct Node*) -> struct Node* - результат деления первого многочлена на второй в поле

Reduc(указатель на struct Node*) -> ничего не возвращает - изменяет переданный многочлен в соответствии с правилами конечных полей
